/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  Address,
  Contract,
  ContractState,
  TestContractResult,
  HexString,
  ContractFactory,
  EventSubscribeOptions,
  EventSubscription,
  CallContractParams,
  CallContractResult,
  TestContractParams,
  ContractEvent,
  subscribeContractEvent,
  subscribeContractEvents,
  testMethod,
  callMethod,
  multicallMethods,
  fetchContractState,
  Asset,
  ContractInstance,
  getContractEventsCurrentCount,
  TestContractParamsWithoutMaps,
  TestContractResultWithoutMaps,
  SignExecuteContractMethodParams,
  SignExecuteScriptTxResult,
  signExecuteMethod,
  addStdIdToFields,
  encodeContractFields,
  Narrow,
} from "@alephium/web3";
import { default as EscrowContractJson } from "../Escrow.ral.json";
import { getContractByCodeHash, registerContract } from "./contracts";

// Custom types for the contract
export namespace EscrowTypes {
  export type Fields = {
    client: Address;
    freelancer: Address;
    arbiter: Address;
    amount: bigint;
    collateral: bigint;
    deadline: bigint;
    cdcHash: HexString;
    trustRegistry: HexString;
    deliverableLink: HexString;
    status: bigint;
  };

  export type State = ContractState<Fields>;

  export type FreelancerAcceptedEvent = ContractEvent<{
    freelancer: Address;
    collateral: bigint;
  }>;
  export type WorkDeliveredEvent = ContractEvent<{
    freelancer: Address;
    link: HexString;
  }>;
  export type PaymentReleasedEvent = ContractEvent<{
    to: Address;
    totalAmount: bigint;
  }>;
  export type DisputeOpenedEvent = ContractEvent<{ opener: Address }>;
  export type DisputeResolvedEvent = ContractEvent<{
    arbiter: Address;
    toFreelancer: boolean;
  }>;
  export type EscrowCancelledEvent = ContractEvent<{ client: Address }>;

  export interface CallMethodTable {
    acceptAndDeposit: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<null>;
    };
    deliver: {
      params: CallContractParams<{ link: HexString }>;
      result: CallContractResult<null>;
    };
    release: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<null>;
    };
    dispute: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<null>;
    };
    resolve: {
      params: CallContractParams<{ toFreelancer: boolean }>;
      result: CallContractResult<null>;
    };
    cancelByClient: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<null>;
    };
    autoClaim: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<null>;
    };
    getStatus: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<bigint>;
    };
    getDeliverableLink: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<HexString>;
    };
    getCdcHash: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<HexString>;
    };
  }
  export type CallMethodParams<T extends keyof CallMethodTable> =
    CallMethodTable[T]["params"];
  export type CallMethodResult<T extends keyof CallMethodTable> =
    CallMethodTable[T]["result"];
  export type MultiCallParams = Partial<{
    [Name in keyof CallMethodTable]: CallMethodTable[Name]["params"];
  }>;
  export type MultiCallResults<T extends MultiCallParams> = {
    [MaybeName in keyof T]: MaybeName extends keyof CallMethodTable
      ? CallMethodTable[MaybeName]["result"]
      : undefined;
  };
  export type MulticallReturnType<Callss extends MultiCallParams[]> = {
    [index in keyof Callss]: MultiCallResults<Callss[index]>;
  };

  export interface SignExecuteMethodTable {
    acceptAndDeposit: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    deliver: {
      params: SignExecuteContractMethodParams<{ link: HexString }>;
      result: SignExecuteScriptTxResult;
    };
    release: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    dispute: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    resolve: {
      params: SignExecuteContractMethodParams<{ toFreelancer: boolean }>;
      result: SignExecuteScriptTxResult;
    };
    cancelByClient: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    autoClaim: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    getStatus: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    getDeliverableLink: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    getCdcHash: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
  }
  export type SignExecuteMethodParams<T extends keyof SignExecuteMethodTable> =
    SignExecuteMethodTable[T]["params"];
  export type SignExecuteMethodResult<T extends keyof SignExecuteMethodTable> =
    SignExecuteMethodTable[T]["result"];
}

class Factory extends ContractFactory<EscrowInstance, EscrowTypes.Fields> {
  encodeFields(fields: EscrowTypes.Fields) {
    return encodeContractFields(
      addStdIdToFields(this.contract, fields),
      this.contract.fieldsSig,
      []
    );
  }

  eventIndex = {
    FreelancerAccepted: 0,
    WorkDelivered: 1,
    PaymentReleased: 2,
    DisputeOpened: 3,
    DisputeResolved: 4,
    EscrowCancelled: 5,
  };
  consts = {
    ErrorCodes: {
      InvalidStatus: BigInt("0"),
      OnlyClient: BigInt("1"),
      OnlyFreelancer: BigInt("2"),
      OnlyArbiter: BigInt("3"),
      OnlyClientOrFreelancer: BigInt("4"),
      AutoClaimTooEarly: BigInt("5"),
    },
  };

  at(address: string): EscrowInstance {
    return new EscrowInstance(address);
  }

  tests = {
    acceptAndDeposit: async (
      params: Omit<
        TestContractParamsWithoutMaps<EscrowTypes.Fields, never>,
        "args"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(
        this,
        "acceptAndDeposit",
        params,
        getContractByCodeHash
      );
    },
    deliver: async (
      params: TestContractParamsWithoutMaps<
        EscrowTypes.Fields,
        { link: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "deliver", params, getContractByCodeHash);
    },
    release: async (
      params: Omit<
        TestContractParamsWithoutMaps<EscrowTypes.Fields, never>,
        "args"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "release", params, getContractByCodeHash);
    },
    dispute: async (
      params: Omit<
        TestContractParamsWithoutMaps<EscrowTypes.Fields, never>,
        "args"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "dispute", params, getContractByCodeHash);
    },
    resolve: async (
      params: TestContractParamsWithoutMaps<
        EscrowTypes.Fields,
        { toFreelancer: boolean }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "resolve", params, getContractByCodeHash);
    },
    cancelByClient: async (
      params: Omit<
        TestContractParamsWithoutMaps<EscrowTypes.Fields, never>,
        "args"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "cancelByClient", params, getContractByCodeHash);
    },
    autoClaim: async (
      params: Omit<
        TestContractParamsWithoutMaps<EscrowTypes.Fields, never>,
        "args"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "autoClaim", params, getContractByCodeHash);
    },
    getStatus: async (
      params: Omit<
        TestContractParamsWithoutMaps<EscrowTypes.Fields, never>,
        "args"
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(this, "getStatus", params, getContractByCodeHash);
    },
    getDeliverableLink: async (
      params: Omit<
        TestContractParamsWithoutMaps<EscrowTypes.Fields, never>,
        "args"
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(
        this,
        "getDeliverableLink",
        params,
        getContractByCodeHash
      );
    },
    getCdcHash: async (
      params: Omit<
        TestContractParamsWithoutMaps<EscrowTypes.Fields, never>,
        "args"
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(this, "getCdcHash", params, getContractByCodeHash);
    },
  };

  stateForTest(
    initFields: EscrowTypes.Fields,
    asset?: Asset,
    address?: string
  ) {
    return this.stateForTest_(initFields, asset, address, undefined);
  }
}

// Use this object to test and deploy the contract
export const Escrow = new Factory(
  Contract.fromJson(
    EscrowContractJson,
    "",
    "eff62d0d8d717d21deabb92da63bbe28390e1da74637a92889738e74e000fbf4",
    []
  )
);
registerContract(Escrow);

// Use this class to interact with the blockchain
export class EscrowInstance extends ContractInstance {
  constructor(address: Address) {
    super(address);
  }

  async fetchState(): Promise<EscrowTypes.State> {
    return fetchContractState(Escrow, this);
  }

  async getContractEventsCurrentCount(): Promise<number> {
    return getContractEventsCurrentCount(this.address);
  }

  subscribeFreelancerAcceptedEvent(
    options: EventSubscribeOptions<EscrowTypes.FreelancerAcceptedEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      Escrow.contract,
      this,
      options,
      "FreelancerAccepted",
      fromCount
    );
  }

  subscribeWorkDeliveredEvent(
    options: EventSubscribeOptions<EscrowTypes.WorkDeliveredEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      Escrow.contract,
      this,
      options,
      "WorkDelivered",
      fromCount
    );
  }

  subscribePaymentReleasedEvent(
    options: EventSubscribeOptions<EscrowTypes.PaymentReleasedEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      Escrow.contract,
      this,
      options,
      "PaymentReleased",
      fromCount
    );
  }

  subscribeDisputeOpenedEvent(
    options: EventSubscribeOptions<EscrowTypes.DisputeOpenedEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      Escrow.contract,
      this,
      options,
      "DisputeOpened",
      fromCount
    );
  }

  subscribeDisputeResolvedEvent(
    options: EventSubscribeOptions<EscrowTypes.DisputeResolvedEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      Escrow.contract,
      this,
      options,
      "DisputeResolved",
      fromCount
    );
  }

  subscribeEscrowCancelledEvent(
    options: EventSubscribeOptions<EscrowTypes.EscrowCancelledEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      Escrow.contract,
      this,
      options,
      "EscrowCancelled",
      fromCount
    );
  }

  subscribeAllEvents(
    options: EventSubscribeOptions<
      | EscrowTypes.FreelancerAcceptedEvent
      | EscrowTypes.WorkDeliveredEvent
      | EscrowTypes.PaymentReleasedEvent
      | EscrowTypes.DisputeOpenedEvent
      | EscrowTypes.DisputeResolvedEvent
      | EscrowTypes.EscrowCancelledEvent
    >,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvents(Escrow.contract, this, options, fromCount);
  }

  view = {
    acceptAndDeposit: async (
      params?: EscrowTypes.CallMethodParams<"acceptAndDeposit">
    ): Promise<EscrowTypes.CallMethodResult<"acceptAndDeposit">> => {
      return callMethod(
        Escrow,
        this,
        "acceptAndDeposit",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    deliver: async (
      params: EscrowTypes.CallMethodParams<"deliver">
    ): Promise<EscrowTypes.CallMethodResult<"deliver">> => {
      return callMethod(Escrow, this, "deliver", params, getContractByCodeHash);
    },
    release: async (
      params?: EscrowTypes.CallMethodParams<"release">
    ): Promise<EscrowTypes.CallMethodResult<"release">> => {
      return callMethod(
        Escrow,
        this,
        "release",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    dispute: async (
      params?: EscrowTypes.CallMethodParams<"dispute">
    ): Promise<EscrowTypes.CallMethodResult<"dispute">> => {
      return callMethod(
        Escrow,
        this,
        "dispute",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    resolve: async (
      params: EscrowTypes.CallMethodParams<"resolve">
    ): Promise<EscrowTypes.CallMethodResult<"resolve">> => {
      return callMethod(Escrow, this, "resolve", params, getContractByCodeHash);
    },
    cancelByClient: async (
      params?: EscrowTypes.CallMethodParams<"cancelByClient">
    ): Promise<EscrowTypes.CallMethodResult<"cancelByClient">> => {
      return callMethod(
        Escrow,
        this,
        "cancelByClient",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    autoClaim: async (
      params?: EscrowTypes.CallMethodParams<"autoClaim">
    ): Promise<EscrowTypes.CallMethodResult<"autoClaim">> => {
      return callMethod(
        Escrow,
        this,
        "autoClaim",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getStatus: async (
      params?: EscrowTypes.CallMethodParams<"getStatus">
    ): Promise<EscrowTypes.CallMethodResult<"getStatus">> => {
      return callMethod(
        Escrow,
        this,
        "getStatus",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getDeliverableLink: async (
      params?: EscrowTypes.CallMethodParams<"getDeliverableLink">
    ): Promise<EscrowTypes.CallMethodResult<"getDeliverableLink">> => {
      return callMethod(
        Escrow,
        this,
        "getDeliverableLink",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getCdcHash: async (
      params?: EscrowTypes.CallMethodParams<"getCdcHash">
    ): Promise<EscrowTypes.CallMethodResult<"getCdcHash">> => {
      return callMethod(
        Escrow,
        this,
        "getCdcHash",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
  };

  transact = {
    acceptAndDeposit: async (
      params: EscrowTypes.SignExecuteMethodParams<"acceptAndDeposit">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"acceptAndDeposit">> => {
      return signExecuteMethod(Escrow, this, "acceptAndDeposit", params);
    },
    deliver: async (
      params: EscrowTypes.SignExecuteMethodParams<"deliver">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"deliver">> => {
      return signExecuteMethod(Escrow, this, "deliver", params);
    },
    release: async (
      params: EscrowTypes.SignExecuteMethodParams<"release">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"release">> => {
      return signExecuteMethod(Escrow, this, "release", params);
    },
    dispute: async (
      params: EscrowTypes.SignExecuteMethodParams<"dispute">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"dispute">> => {
      return signExecuteMethod(Escrow, this, "dispute", params);
    },
    resolve: async (
      params: EscrowTypes.SignExecuteMethodParams<"resolve">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"resolve">> => {
      return signExecuteMethod(Escrow, this, "resolve", params);
    },
    cancelByClient: async (
      params: EscrowTypes.SignExecuteMethodParams<"cancelByClient">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"cancelByClient">> => {
      return signExecuteMethod(Escrow, this, "cancelByClient", params);
    },
    autoClaim: async (
      params: EscrowTypes.SignExecuteMethodParams<"autoClaim">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"autoClaim">> => {
      return signExecuteMethod(Escrow, this, "autoClaim", params);
    },
    getStatus: async (
      params: EscrowTypes.SignExecuteMethodParams<"getStatus">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"getStatus">> => {
      return signExecuteMethod(Escrow, this, "getStatus", params);
    },
    getDeliverableLink: async (
      params: EscrowTypes.SignExecuteMethodParams<"getDeliverableLink">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"getDeliverableLink">> => {
      return signExecuteMethod(Escrow, this, "getDeliverableLink", params);
    },
    getCdcHash: async (
      params: EscrowTypes.SignExecuteMethodParams<"getCdcHash">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"getCdcHash">> => {
      return signExecuteMethod(Escrow, this, "getCdcHash", params);
    },
  };

  async multicall<Calls extends EscrowTypes.MultiCallParams>(
    calls: Calls
  ): Promise<EscrowTypes.MultiCallResults<Calls>>;
  async multicall<Callss extends EscrowTypes.MultiCallParams[]>(
    callss: Narrow<Callss>
  ): Promise<EscrowTypes.MulticallReturnType<Callss>>;
  async multicall<
    Callss extends EscrowTypes.MultiCallParams | EscrowTypes.MultiCallParams[]
  >(callss: Callss): Promise<unknown> {
    return await multicallMethods(Escrow, this, callss, getContractByCodeHash);
  }
}
