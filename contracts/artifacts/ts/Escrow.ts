/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  Address,
  Contract,
  ContractState,
  TestContractResult,
  HexString,
  ContractFactory,
  EventSubscribeOptions,
  EventSubscription,
  CallContractParams,
  CallContractResult,
  TestContractParams,
  ContractEvent,
  subscribeContractEvent,
  subscribeContractEvents,
  testMethod,
  callMethod,
  multicallMethods,
  fetchContractState,
  Asset,
  ContractInstance,
  getContractEventsCurrentCount,
  TestContractParamsWithoutMaps,
  TestContractResultWithoutMaps,
  SignExecuteContractMethodParams,
  SignExecuteScriptTxResult,
  signExecuteMethod,
  addStdIdToFields,
  encodeContractFields,
  Narrow,
} from "@alephium/web3";
import { default as EscrowContractJson } from "../Escrow.ral.json";
import { getContractByCodeHash, registerContract } from "./contracts";

// Custom types for the contract
export namespace EscrowTypes {
  export type Fields = {
    client: Address;
    freelancer: Address;
    arbiter: Address;
    amount: bigint;
    collateral: bigint;
    deadline: bigint;
    cdcHash: HexString;
    trustRegistry: HexString;
    deliverableLink: HexString;
    status: bigint;
    disputeReason: HexString;
    disputeEvidence: HexString;
    disputeJustification: HexString;
  };

  export type State = ContractState<Fields>;

  export type FreelancerAcceptedEvent = ContractEvent<{
    freelancer: Address;
    collateral: bigint;
  }>;
  export type WorkDeliveredEvent = ContractEvent<{
    freelancer: Address;
    link: HexString;
  }>;
  export type PaymentReleasedEvent = ContractEvent<{
    to: Address;
    totalAmount: bigint;
  }>;
  export type DisputeOpenedEvent = ContractEvent<{
    opener: Address;
    reason: HexString;
  }>;
  export type EvidenceSubmittedEvent = ContractEvent<{
    submitter: Address;
    evidence: HexString;
  }>;
  export type DisputeResolvedEvent = ContractEvent<{
    arbiter: Address;
    freelancerPercent: bigint;
    justification: HexString;
  }>;
  export type EscrowCancelledEvent = ContractEvent<{ client: Address }>;
  export type FreelancerRefundedEvent = ContractEvent<{ freelancer: Address }>;

  export interface CallMethodTable {
    acceptAndDeposit: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<null>;
    };
    deliver: {
      params: CallContractParams<{ link: HexString }>;
      result: CallContractResult<null>;
    };
    release: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<null>;
    };
    dispute: {
      params: CallContractParams<{ reason: HexString }>;
      result: CallContractResult<null>;
    };
    submitEvidence: {
      params: CallContractParams<{ evidence: HexString }>;
      result: CallContractResult<null>;
    };
    resolve: {
      params: CallContractParams<{
        freelancerPercent: bigint;
        justification: HexString;
      }>;
      result: CallContractResult<null>;
    };
    refundByFreelancer: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<null>;
    };
    cancelByClient: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<null>;
    };
    autoClaim: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<null>;
    };
    getStatus: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<bigint>;
    };
    getDeliverableLink: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<HexString>;
    };
    getCdcHash: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<HexString>;
    };
    getDisputeReason: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<HexString>;
    };
    getDisputeEvidence: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<HexString>;
    };
    getDisputeJustification: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<HexString>;
    };
  }
  export type CallMethodParams<T extends keyof CallMethodTable> =
    CallMethodTable[T]["params"];
  export type CallMethodResult<T extends keyof CallMethodTable> =
    CallMethodTable[T]["result"];
  export type MultiCallParams = Partial<{
    [Name in keyof CallMethodTable]: CallMethodTable[Name]["params"];
  }>;
  export type MultiCallResults<T extends MultiCallParams> = {
    [MaybeName in keyof T]: MaybeName extends keyof CallMethodTable
      ? CallMethodTable[MaybeName]["result"]
      : undefined;
  };
  export type MulticallReturnType<Callss extends MultiCallParams[]> = {
    [index in keyof Callss]: MultiCallResults<Callss[index]>;
  };

  export interface SignExecuteMethodTable {
    acceptAndDeposit: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    deliver: {
      params: SignExecuteContractMethodParams<{ link: HexString }>;
      result: SignExecuteScriptTxResult;
    };
    release: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    dispute: {
      params: SignExecuteContractMethodParams<{ reason: HexString }>;
      result: SignExecuteScriptTxResult;
    };
    submitEvidence: {
      params: SignExecuteContractMethodParams<{ evidence: HexString }>;
      result: SignExecuteScriptTxResult;
    };
    resolve: {
      params: SignExecuteContractMethodParams<{
        freelancerPercent: bigint;
        justification: HexString;
      }>;
      result: SignExecuteScriptTxResult;
    };
    refundByFreelancer: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    cancelByClient: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    autoClaim: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    getStatus: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    getDeliverableLink: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    getCdcHash: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    getDisputeReason: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    getDisputeEvidence: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
    getDisputeJustification: {
      params: Omit<SignExecuteContractMethodParams<{}>, "args">;
      result: SignExecuteScriptTxResult;
    };
  }
  export type SignExecuteMethodParams<T extends keyof SignExecuteMethodTable> =
    SignExecuteMethodTable[T]["params"];
  export type SignExecuteMethodResult<T extends keyof SignExecuteMethodTable> =
    SignExecuteMethodTable[T]["result"];
}

class Factory extends ContractFactory<EscrowInstance, EscrowTypes.Fields> {
  encodeFields(fields: EscrowTypes.Fields) {
    return encodeContractFields(
      addStdIdToFields(this.contract, fields),
      this.contract.fieldsSig,
      []
    );
  }

  eventIndex = {
    FreelancerAccepted: 0,
    WorkDelivered: 1,
    PaymentReleased: 2,
    DisputeOpened: 3,
    EvidenceSubmitted: 4,
    DisputeResolved: 5,
    EscrowCancelled: 6,
    FreelancerRefunded: 7,
  };
  consts = {
    ErrorCodes: {
      InvalidStatus: BigInt("0"),
      OnlyClient: BigInt("1"),
      OnlyFreelancer: BigInt("2"),
      OnlyArbiter: BigInt("3"),
      OnlyClientOrFreelancer: BigInt("4"),
      AutoClaimTooEarly: BigInt("5"),
      EvidenceAlreadySubmitted: BigInt("6"),
      InvalidPercent: BigInt("7"),
    },
  };

  at(address: string): EscrowInstance {
    return new EscrowInstance(address);
  }

  tests = {
    acceptAndDeposit: async (
      params: Omit<
        TestContractParamsWithoutMaps<EscrowTypes.Fields, never>,
        "args"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(
        this,
        "acceptAndDeposit",
        params,
        getContractByCodeHash
      );
    },
    deliver: async (
      params: TestContractParamsWithoutMaps<
        EscrowTypes.Fields,
        { link: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "deliver", params, getContractByCodeHash);
    },
    release: async (
      params: Omit<
        TestContractParamsWithoutMaps<EscrowTypes.Fields, never>,
        "args"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "release", params, getContractByCodeHash);
    },
    dispute: async (
      params: TestContractParamsWithoutMaps<
        EscrowTypes.Fields,
        { reason: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "dispute", params, getContractByCodeHash);
    },
    submitEvidence: async (
      params: TestContractParamsWithoutMaps<
        EscrowTypes.Fields,
        { evidence: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "submitEvidence", params, getContractByCodeHash);
    },
    resolve: async (
      params: TestContractParamsWithoutMaps<
        EscrowTypes.Fields,
        { freelancerPercent: bigint; justification: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "resolve", params, getContractByCodeHash);
    },
    refundByFreelancer: async (
      params: Omit<
        TestContractParamsWithoutMaps<EscrowTypes.Fields, never>,
        "args"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(
        this,
        "refundByFreelancer",
        params,
        getContractByCodeHash
      );
    },
    cancelByClient: async (
      params: Omit<
        TestContractParamsWithoutMaps<EscrowTypes.Fields, never>,
        "args"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "cancelByClient", params, getContractByCodeHash);
    },
    autoClaim: async (
      params: Omit<
        TestContractParamsWithoutMaps<EscrowTypes.Fields, never>,
        "args"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "autoClaim", params, getContractByCodeHash);
    },
    getStatus: async (
      params: Omit<
        TestContractParamsWithoutMaps<EscrowTypes.Fields, never>,
        "args"
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(this, "getStatus", params, getContractByCodeHash);
    },
    getDeliverableLink: async (
      params: Omit<
        TestContractParamsWithoutMaps<EscrowTypes.Fields, never>,
        "args"
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(
        this,
        "getDeliverableLink",
        params,
        getContractByCodeHash
      );
    },
    getCdcHash: async (
      params: Omit<
        TestContractParamsWithoutMaps<EscrowTypes.Fields, never>,
        "args"
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(this, "getCdcHash", params, getContractByCodeHash);
    },
    getDisputeReason: async (
      params: Omit<
        TestContractParamsWithoutMaps<EscrowTypes.Fields, never>,
        "args"
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(
        this,
        "getDisputeReason",
        params,
        getContractByCodeHash
      );
    },
    getDisputeEvidence: async (
      params: Omit<
        TestContractParamsWithoutMaps<EscrowTypes.Fields, never>,
        "args"
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(
        this,
        "getDisputeEvidence",
        params,
        getContractByCodeHash
      );
    },
    getDisputeJustification: async (
      params: Omit<
        TestContractParamsWithoutMaps<EscrowTypes.Fields, never>,
        "args"
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(
        this,
        "getDisputeJustification",
        params,
        getContractByCodeHash
      );
    },
  };

  stateForTest(
    initFields: EscrowTypes.Fields,
    asset?: Asset,
    address?: string
  ) {
    return this.stateForTest_(initFields, asset, address, undefined);
  }
}

// Use this object to test and deploy the contract
export const Escrow = new Factory(
  Contract.fromJson(
    EscrowContractJson,
    "",
    "65557a98ce1ae17717f6dc781f35aefa899fbbe4e92f758f70c1dcdf9a1be965",
    []
  )
);
registerContract(Escrow);

// Use this class to interact with the blockchain
export class EscrowInstance extends ContractInstance {
  constructor(address: Address) {
    super(address);
  }

  async fetchState(): Promise<EscrowTypes.State> {
    return fetchContractState(Escrow, this);
  }

  async getContractEventsCurrentCount(): Promise<number> {
    return getContractEventsCurrentCount(this.address);
  }

  subscribeFreelancerAcceptedEvent(
    options: EventSubscribeOptions<EscrowTypes.FreelancerAcceptedEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      Escrow.contract,
      this,
      options,
      "FreelancerAccepted",
      fromCount
    );
  }

  subscribeWorkDeliveredEvent(
    options: EventSubscribeOptions<EscrowTypes.WorkDeliveredEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      Escrow.contract,
      this,
      options,
      "WorkDelivered",
      fromCount
    );
  }

  subscribePaymentReleasedEvent(
    options: EventSubscribeOptions<EscrowTypes.PaymentReleasedEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      Escrow.contract,
      this,
      options,
      "PaymentReleased",
      fromCount
    );
  }

  subscribeDisputeOpenedEvent(
    options: EventSubscribeOptions<EscrowTypes.DisputeOpenedEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      Escrow.contract,
      this,
      options,
      "DisputeOpened",
      fromCount
    );
  }

  subscribeEvidenceSubmittedEvent(
    options: EventSubscribeOptions<EscrowTypes.EvidenceSubmittedEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      Escrow.contract,
      this,
      options,
      "EvidenceSubmitted",
      fromCount
    );
  }

  subscribeDisputeResolvedEvent(
    options: EventSubscribeOptions<EscrowTypes.DisputeResolvedEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      Escrow.contract,
      this,
      options,
      "DisputeResolved",
      fromCount
    );
  }

  subscribeEscrowCancelledEvent(
    options: EventSubscribeOptions<EscrowTypes.EscrowCancelledEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      Escrow.contract,
      this,
      options,
      "EscrowCancelled",
      fromCount
    );
  }

  subscribeFreelancerRefundedEvent(
    options: EventSubscribeOptions<EscrowTypes.FreelancerRefundedEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      Escrow.contract,
      this,
      options,
      "FreelancerRefunded",
      fromCount
    );
  }

  subscribeAllEvents(
    options: EventSubscribeOptions<
      | EscrowTypes.FreelancerAcceptedEvent
      | EscrowTypes.WorkDeliveredEvent
      | EscrowTypes.PaymentReleasedEvent
      | EscrowTypes.DisputeOpenedEvent
      | EscrowTypes.EvidenceSubmittedEvent
      | EscrowTypes.DisputeResolvedEvent
      | EscrowTypes.EscrowCancelledEvent
      | EscrowTypes.FreelancerRefundedEvent
    >,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvents(Escrow.contract, this, options, fromCount);
  }

  view = {
    acceptAndDeposit: async (
      params?: EscrowTypes.CallMethodParams<"acceptAndDeposit">
    ): Promise<EscrowTypes.CallMethodResult<"acceptAndDeposit">> => {
      return callMethod(
        Escrow,
        this,
        "acceptAndDeposit",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    deliver: async (
      params: EscrowTypes.CallMethodParams<"deliver">
    ): Promise<EscrowTypes.CallMethodResult<"deliver">> => {
      return callMethod(Escrow, this, "deliver", params, getContractByCodeHash);
    },
    release: async (
      params?: EscrowTypes.CallMethodParams<"release">
    ): Promise<EscrowTypes.CallMethodResult<"release">> => {
      return callMethod(
        Escrow,
        this,
        "release",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    dispute: async (
      params: EscrowTypes.CallMethodParams<"dispute">
    ): Promise<EscrowTypes.CallMethodResult<"dispute">> => {
      return callMethod(Escrow, this, "dispute", params, getContractByCodeHash);
    },
    submitEvidence: async (
      params: EscrowTypes.CallMethodParams<"submitEvidence">
    ): Promise<EscrowTypes.CallMethodResult<"submitEvidence">> => {
      return callMethod(
        Escrow,
        this,
        "submitEvidence",
        params,
        getContractByCodeHash
      );
    },
    resolve: async (
      params: EscrowTypes.CallMethodParams<"resolve">
    ): Promise<EscrowTypes.CallMethodResult<"resolve">> => {
      return callMethod(Escrow, this, "resolve", params, getContractByCodeHash);
    },
    refundByFreelancer: async (
      params?: EscrowTypes.CallMethodParams<"refundByFreelancer">
    ): Promise<EscrowTypes.CallMethodResult<"refundByFreelancer">> => {
      return callMethod(
        Escrow,
        this,
        "refundByFreelancer",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    cancelByClient: async (
      params?: EscrowTypes.CallMethodParams<"cancelByClient">
    ): Promise<EscrowTypes.CallMethodResult<"cancelByClient">> => {
      return callMethod(
        Escrow,
        this,
        "cancelByClient",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    autoClaim: async (
      params?: EscrowTypes.CallMethodParams<"autoClaim">
    ): Promise<EscrowTypes.CallMethodResult<"autoClaim">> => {
      return callMethod(
        Escrow,
        this,
        "autoClaim",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getStatus: async (
      params?: EscrowTypes.CallMethodParams<"getStatus">
    ): Promise<EscrowTypes.CallMethodResult<"getStatus">> => {
      return callMethod(
        Escrow,
        this,
        "getStatus",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getDeliverableLink: async (
      params?: EscrowTypes.CallMethodParams<"getDeliverableLink">
    ): Promise<EscrowTypes.CallMethodResult<"getDeliverableLink">> => {
      return callMethod(
        Escrow,
        this,
        "getDeliverableLink",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getCdcHash: async (
      params?: EscrowTypes.CallMethodParams<"getCdcHash">
    ): Promise<EscrowTypes.CallMethodResult<"getCdcHash">> => {
      return callMethod(
        Escrow,
        this,
        "getCdcHash",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getDisputeReason: async (
      params?: EscrowTypes.CallMethodParams<"getDisputeReason">
    ): Promise<EscrowTypes.CallMethodResult<"getDisputeReason">> => {
      return callMethod(
        Escrow,
        this,
        "getDisputeReason",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getDisputeEvidence: async (
      params?: EscrowTypes.CallMethodParams<"getDisputeEvidence">
    ): Promise<EscrowTypes.CallMethodResult<"getDisputeEvidence">> => {
      return callMethod(
        Escrow,
        this,
        "getDisputeEvidence",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getDisputeJustification: async (
      params?: EscrowTypes.CallMethodParams<"getDisputeJustification">
    ): Promise<EscrowTypes.CallMethodResult<"getDisputeJustification">> => {
      return callMethod(
        Escrow,
        this,
        "getDisputeJustification",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
  };

  transact = {
    acceptAndDeposit: async (
      params: EscrowTypes.SignExecuteMethodParams<"acceptAndDeposit">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"acceptAndDeposit">> => {
      return signExecuteMethod(Escrow, this, "acceptAndDeposit", params);
    },
    deliver: async (
      params: EscrowTypes.SignExecuteMethodParams<"deliver">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"deliver">> => {
      return signExecuteMethod(Escrow, this, "deliver", params);
    },
    release: async (
      params: EscrowTypes.SignExecuteMethodParams<"release">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"release">> => {
      return signExecuteMethod(Escrow, this, "release", params);
    },
    dispute: async (
      params: EscrowTypes.SignExecuteMethodParams<"dispute">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"dispute">> => {
      return signExecuteMethod(Escrow, this, "dispute", params);
    },
    submitEvidence: async (
      params: EscrowTypes.SignExecuteMethodParams<"submitEvidence">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"submitEvidence">> => {
      return signExecuteMethod(Escrow, this, "submitEvidence", params);
    },
    resolve: async (
      params: EscrowTypes.SignExecuteMethodParams<"resolve">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"resolve">> => {
      return signExecuteMethod(Escrow, this, "resolve", params);
    },
    refundByFreelancer: async (
      params: EscrowTypes.SignExecuteMethodParams<"refundByFreelancer">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"refundByFreelancer">> => {
      return signExecuteMethod(Escrow, this, "refundByFreelancer", params);
    },
    cancelByClient: async (
      params: EscrowTypes.SignExecuteMethodParams<"cancelByClient">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"cancelByClient">> => {
      return signExecuteMethod(Escrow, this, "cancelByClient", params);
    },
    autoClaim: async (
      params: EscrowTypes.SignExecuteMethodParams<"autoClaim">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"autoClaim">> => {
      return signExecuteMethod(Escrow, this, "autoClaim", params);
    },
    getStatus: async (
      params: EscrowTypes.SignExecuteMethodParams<"getStatus">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"getStatus">> => {
      return signExecuteMethod(Escrow, this, "getStatus", params);
    },
    getDeliverableLink: async (
      params: EscrowTypes.SignExecuteMethodParams<"getDeliverableLink">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"getDeliverableLink">> => {
      return signExecuteMethod(Escrow, this, "getDeliverableLink", params);
    },
    getCdcHash: async (
      params: EscrowTypes.SignExecuteMethodParams<"getCdcHash">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"getCdcHash">> => {
      return signExecuteMethod(Escrow, this, "getCdcHash", params);
    },
    getDisputeReason: async (
      params: EscrowTypes.SignExecuteMethodParams<"getDisputeReason">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"getDisputeReason">> => {
      return signExecuteMethod(Escrow, this, "getDisputeReason", params);
    },
    getDisputeEvidence: async (
      params: EscrowTypes.SignExecuteMethodParams<"getDisputeEvidence">
    ): Promise<EscrowTypes.SignExecuteMethodResult<"getDisputeEvidence">> => {
      return signExecuteMethod(Escrow, this, "getDisputeEvidence", params);
    },
    getDisputeJustification: async (
      params: EscrowTypes.SignExecuteMethodParams<"getDisputeJustification">
    ): Promise<
      EscrowTypes.SignExecuteMethodResult<"getDisputeJustification">
    > => {
      return signExecuteMethod(Escrow, this, "getDisputeJustification", params);
    },
  };

  async multicall<Calls extends EscrowTypes.MultiCallParams>(
    calls: Calls
  ): Promise<EscrowTypes.MultiCallResults<Calls>>;
  async multicall<Callss extends EscrowTypes.MultiCallParams[]>(
    callss: Narrow<Callss>
  ): Promise<EscrowTypes.MulticallReturnType<Callss>>;
  async multicall<
    Callss extends EscrowTypes.MultiCallParams | EscrowTypes.MultiCallParams[]
  >(callss: Callss): Promise<unknown> {
    return await multicallMethods(Escrow, this, callss, getContractByCodeHash);
  }
}
